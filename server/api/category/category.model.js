'use strict';

var mongoose  = require('mongoose'),
    treePlugin = require('mongoose-path-tree'),
    Schema = mongoose.Schema,
    async = require('async'),
    _     = require('lodash');

var CategorySchema = new Schema({
  name: String,
  slug: String,
  info: String,
  description: String,
  images:[{ type: Schema.Types.ObjectId, ref: 'Image'}],
  parent:{ type: Schema.Types.ObjectId, ref: 'Category' ,default: null},
  created: { type: Date, default: Date.now },
  updated: { type: Date, default: Date.now },
  active: Boolean

});

CategorySchema.plugin(treePlugin, {
          pathSeparator : '#',              // Default path separator
          onDelete :      'REPARENT',       // Can be set to 'DELETE' or 'REPARENT'. Default: 'REPARENT'
          numWorkers:     5,                // Number of stream workers
          idType: Schema.ObjectId  // Type used for _id. Can be, for example, String generated by shortid module
});

CategorySchema.statics.getTree = function(options,callback){

    this.find({$or:[{ "parent" : { "$exists" : false }},{"parent":null} ]} ).exec(function(err,parents){
      if(err){return callback(err);}
      var results = [];

      async.forEach(parents,function(parent,cb){
        parent.getTree({columns:"name",},function(err,tree){
          if(err){return cb(err);}
          results.push(tree);
          cb();
        });
      },function(err){
        if(err){return callback(err);}
        callback(null,results);
      }
      )
    });
};



CategorySchema.methods.getTree = function(options,cb){
    var self = this;
  this.getChildrenTree(options,function(err,subtree){
    var tree = {}
    if (subtree[0]){console.log('subtree',subtree[0]);}

    //_.assign(self._doc,{children:subtree});
    self.set( 'children',subtree, { strict: false });
    cb(err,self);
  });
};

CategorySchema.set('toJSON', { virtuals: true });
CategorySchema.set('toObject', { virtuals: true });

module.exports = mongoose.model('Category', CategorySchema);
